Below is a proposed BNF-style grammar for the Trust language, aligned with our parser’s structure and AST nodes:

```bnf
<Program>        ::= <TopLevel>* EOF

<TopLevel>      ::= <FunctionDecl>
                   | <Statement> SEMI?

<Statement>     ::= <LetDecl>
                   | <TypeDecl>
                   | <AssignStmt>
                   | <ReturnStmt>
                   | <BreakStmt>
                   | <ContinueStmt>
                   | <IfStmt>
                   | <LoopStmt>
                   | <PrintStmt>
                   | <ExprStmt>

<LetDecl>       ::= "let" "mut"? <Pattern> (":" <Type>)? ("=" <Expression>)?
<Pattern>       ::= <Id>
                   | "(" <PatternList> ")"
<PatternList>   ::= <Pattern> ("," <Pattern>)*

<TypeDecl>      ::= <Type> <Id> ("=" <Expression>)?

<AssignStmt>    ::= <LValue> "=" <Expression>
<LValue>        ::= <Id> ("[" <Expression> "]")*

<ReturnStmt>    ::= "return" <Expression>?
<BreakStmt>     ::= "break"
<ContinueStmt>  ::= "continue"

<IfStmt>        ::= "if" <Expression> <Block> ("else" ("if" <Expression> <Block> | <Block>))?
<LoopStmt>      ::= "loop" <Block>
<Block>         ::= "{" <Statement>* "}"

<PrintStmt>     ::= "println!" "(" <StringLiteral> ("," (<Expression> | <Id> "=" <Expression>))* ")"

<ExprStmt>      ::= <Expression>

<FunctionDecl>  ::= "fn" <Id> "(" <ParamList>? ")" ("->" <Type>)? <Block>
<ParamList>     ::= <Param> ("," <Param>)*
<Param>         ::= <Id> (":" <Type>)?

<Type>          ::= "bool"
                   | "i32"
                   | "(" <TypeList> ")"
                   | "[" <Type> (";" <Decimal>)? "]"
<TypeList>      ::= <Type> ("," <Type>)*

<Expression>    ::= <UnaryExpr> (<BinaryOp> <Expression>)*
<UnaryExpr>     ::= ("!" | "+" | "-") <Expression>
                   | <Primary>
<Primary>       ::= <Decimal>
                   | <Hexadecimal>
                   | <StringLiteral>
                   | <BoolLiteral>
                   | <TupleLiteral>
                   | <ArrayLiteral>
                   | <Call>
                   | <Id>
                   | "(" <Expression> ")"
                   | <Id> "[" <Expression> "]"

<Call>          ::= <Id> "(" <ArgList>? ")"
<ArgList>       ::= <Expression> ("," <Expression>)*

<TupleLiteral>  ::= "(" <Expression> ("," <Expression>)* ")"
<ArrayLiteral>  ::= "[" (<Expression> ("," <Expression>)* | <Expression> ";" <Expression>)? "]"

<Decimal>       ::= /[0-9]+/
<Hexadecimal>   ::= /0x[0-9A-Fa-f]+/
<StringLiteral> ::= /".*?"/
<BoolLiteral>   ::= "true" | "false"
<Id>            ::= /[A-Za-z_]\w*/
<SEMI>          ::= ";"
```

**Notes:**

* `TypeDecl` covers standalone declarations without a leading `let` (e.g. `bool flag = false;`).
* Array repetition syntax `[expr; count]` is represented by the `ArrayLiteral` rule.
* Conditional chaining (`else if`) is captured by the optional `else` production.
* Expression precedence (logical, relational, arithmetic) is handled by the parser’s precedence table rather than directly in the grammar here.

This grammar mirrors the parser code’s productions and should serve as a clear language specification. Feel free to adjust nonterminal names or arrangements to suit your tooling or documentation style.
